{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "id_final 21743\n"
     ]
    }
   ],
   "source": [
    "from SimpleGraphics import *\n",
    "from quantum_rules import *\n",
    "from random import randrange, shuffle\n",
    "from time import time, sleep\n",
    "from math import sin, pi\n",
    "import numpy as np\n",
    "from copy import deepcopy\n",
    "from pprint import pprint\n",
    "import random as random\n",
    "import inspect\n",
    "import sys\n",
    "import traceback\n",
    "import os\n",
    "\n",
    "# Where is the 'hole' for the game board in the background image?\n",
    "HOFF = 200\n",
    "VOFF = 100\n",
    "\n",
    "# Where should the score, target and turn counter boxes be centered?\n",
    "SCORE_X = 700\n",
    "SCORE_Y = 300\n",
    "\n",
    "# Special game pieces\n",
    "EMPTY = -1\n",
    "BURST = 6\n",
    "\n",
    "# Game state\n",
    "RUNNING = 0\n",
    "WIN = 1\n",
    "LOSE = -1\n",
    "\n",
    "###############################################################################\n",
    "#\n",
    "#  Code\n",
    "#\n",
    "###############################################################################\n",
    "def createBoard(rows, cols, num_syms):\n",
    "  board = []\n",
    "\n",
    "  for r in range(rows):\n",
    "    board.append([])\n",
    "    for c in range(cols):\n",
    "     # board[r].append(randrange(0, num_syms))\n",
    "       board[r].append(random.choice ([1,2,3,4]))\n",
    "  return board\n",
    "\n",
    "id_final = check_identity()\n",
    "print(\"id_final\",len(id_final))\n",
    "\n",
    "# Check for a vertical line at r1, c1\n",
    "def vLineAt(board, r1, c1):\n",
    "  b =np.array(board) \n",
    "  if r1-8>=0 or list( b[r1-8:r1,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-7>=0 or list(b[r1-7:r1,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-6>=0 or list(b[r1-6:r1,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-5>=0 or list(b[r1-5:r1,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-4>=0 or list(b[r1-4:r1,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-3>=0 or list(b[r1-3:r1,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-2 >= 0 or list(b[r1-2:r1,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-2 >= 0 or r1+1 < len(board)\\\n",
    "     or list(b[r1-2:r1+1,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-2 >= 0 or r1+2 < len(board)\\\n",
    "     or list(b[r1-2:r1+2,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-2 >= 0 or r1+3 < len(board)\\\n",
    "     or list(b[r1-2:r1+3,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-2 >= 0 or r1+4 < len(board)\\\n",
    "     or list(b[r1-2:r1+4,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-2 >= 0 or r1+5 < len(board)\\\n",
    "     or list(b[r1-2:r1+5,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-2 >= 0 or r1+6 < len(board)\\\n",
    "     or list(b[r1-2:r1+6,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-1 >= 0 or r1+1 < len(board) and \\\n",
    "     list(b[r1-1:r1+1,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-1 >= 0 or r1+2 < len(board) or \\\n",
    "     list(b[r1-1:r1+2,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-1 >= 0 or r1+3 < len(board) or \\\n",
    "     list(b[r1-1:r1+3,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-1 >= 0 or r1+4 < len(board) or \\\n",
    "     list(b[r1-1:r1+4,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-1 >= 0 or r1+5 < len(board) or \\\n",
    "     list(b[r1-1:r1+5,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-1 >= 0 or r1+6 < len(board) or \\\n",
    "     list(b[r1-1:r1+6,c1]) in id_final:\n",
    "    return True\n",
    "  if r1-1 >= 0 or r1+7 < len(board) or \\\n",
    "     list(b[r1-1:r1+7,c1]) in id_final:\n",
    "    return True\n",
    "  if r1+2 < len(board) or \\\n",
    "     list(b[r1:r1+2,c1]) in id_final:\n",
    "    return True\n",
    "  if r1+3 < len(board) or \\\n",
    "     list(b[r1:r1+3,c1]) in id_final:\n",
    "    return True\n",
    "  if r1+4 < len(board) or \\\n",
    "     list(b[r1:r1+4,c1]) in id_final:\n",
    "    return True\n",
    "  if r1+5 < len(board) or \\\n",
    "     list(b[r1:r1+5,c1]) in id_final:\n",
    "    return True\n",
    "  if r1+6 < len(board) or \\\n",
    "     list(b[r1:r1+6,c1]) in id_final:\n",
    "    return True\n",
    "  if r1+7 < len(board) or \\\n",
    "     list(b[r1:r1+7,c1]) in id_final:\n",
    "    return True\n",
    "  if r1+8 < len(board) or \\\n",
    "     list(b[r1:r1+8,c1]) in id_final:\n",
    "    return True\n",
    "\n",
    "  return False\n",
    "\n",
    "# Check for a horizontal line at r1, c1\n",
    "def hLineAt(board, r1, c1):\n",
    "  b = np.array(board)\n",
    "  if c1-8>=0 or list(b[r1,c1-8:c1]) in id_final:\n",
    "    return True\n",
    "  if c1-7>=0 or list(b[r1,c1-7:c1]) in id_final:\n",
    "    return True\n",
    "  if c1-6>=0 or list(b[r1,c1-6:c1])in id_final:\n",
    "    return True\n",
    "  if c1-5>=0 or list(b[r1,c1-5:c1]) in id_final:\n",
    "    return True\n",
    "  if c1-4>=0 or list(b[r1,c1-4:c1]) in id_final:\n",
    "    return True\n",
    "  if c1-3>=0 or list(b[r1,c1-3:c1]) in id_final:\n",
    "    return True\n",
    "  if c1-2>=0 or list(b[r1,c1-2:c1]) in id_final:\n",
    "    return True\n",
    "  if c1-2 >= 0 or c1+1 < len(b)\\\n",
    "     or list(b[r1,c1-2:c1+1]) in id_final:\n",
    "    return True\n",
    "  if c1-2 >= 0 or c1+2 < len(b)\\\n",
    "     or list(b[r1,c1-2:c1+2]) in id_final:\n",
    "    return True\n",
    "  if c1-2 >= 0 or c1+3 < len(b)\\\n",
    "     or list(b[r1,c1-2:c1+3])in id_final:\n",
    "    return True\n",
    "  if c1-2 >= 0 or c1+4 < len(b)\\\n",
    "     or list(b[r1,c1-2:c1+4]) in id_final:\n",
    "    return True\n",
    "  if c1-2 >= 0 or c1+5 < len(b)\\\n",
    "     or list(b[r1,c1-2:c1+5]) in id_final:\n",
    "    return True\n",
    "  if c1-2 >= 0 or c1+6 < len(b)\\\n",
    "     or list(b[r1,c1-2:c1+6]) in id_final:\n",
    "    return True\n",
    "  if c1-1 >= 0 or c1+1 < len(b) or \\\n",
    "     list(b[r1,c1-1:c1+1]) in id_final:\n",
    "    return True\n",
    "  if c1-1 >= 0 or c1+2 < len(b) or \\\n",
    "     list(b[r1,c1-1:c1+2]) in id_final:\n",
    "    return True\n",
    "  if c1-1 >= 0 or c1+3 < len(b) or \\\n",
    "     list(b[r1,c1-1:c1+3]) in id_final:\n",
    "    return True\n",
    "  if c1-1 >= 0 or c1+4 < len(b) or \\\n",
    "     list(b[r1,c1-1:c1+4]) in id_final:\n",
    "    return True\n",
    "  if c1-1 >= 0 or c1+5 < len(b) or \\\n",
    "     list(b[r1,c1-1:c1+5] )in id_final:\n",
    "    return True\n",
    "  if c1-1 >= 0 or c1+6 < len(b) or \\\n",
    "     list(b[r1,c1-1:c1+6]) in id_final:\n",
    "    return True\n",
    "  if c1-1 >= 0 or c1+7 < len(b) or \\\n",
    "     list(b[r1,c1-1:c1+7]) in id_final:\n",
    "    return True\n",
    "  if c1+2 < len(b) or \\\n",
    "     list(b[r1,c1:c1+2]) in id_final:\n",
    "    return True\n",
    "  if c1+3 < len(b) or \\\n",
    "     list(b[r1,c1:c1+3]) in id_final:\n",
    "    return True\n",
    "  if c1+4 < len(b) or \\\n",
    "     list(b[r1,c1:c1+4]) in id_final:\n",
    "    return True\n",
    "  if c1+5 < len(b) or\\\n",
    "     list(b[r1,c1:c1+5])in id_final:\n",
    "    return True\n",
    "  if c1+6 < len(b) or \\\n",
    "     list(b[r1,c1:c1+6] )in id_final:\n",
    "    return True\n",
    "  if c1+7 < len(b) or \\\n",
    "     list(b[r1,c1:c1+7] )in id_final:\n",
    "    return True\n",
    "  if c1+8 < len(b) or \\\n",
    "     list(b[r1,c1:c1+8]) in id_final:\n",
    "    return True\n",
    "\n",
    "  return False\n",
    "\n",
    "#\n",
    "#  Modifies the board in place.  Returns None.\n",
    "#\n",
    "def swap(board, r1, c1, r2, c2):\n",
    "  temp = board[r1][c1]\n",
    "  board[r1][c1] = board[r2][c2]\n",
    "  board[r2][c2] = temp\n",
    "\n",
    "#\n",
    "#  Need to check if we have a line of (at least 3) in either place as a \n",
    "#  result of the swap since there is no guarantee on the order\n",
    "#\n",
    "def canSwap(board, r1, c1, r2, c2):\n",
    "  # Swap them\n",
    "  swap(board, r1, c1, r2, c2)\n",
    "\n",
    "  if hLineAt(board, r1, c1) or hLineAt(board, r2, c2) or \\\n",
    "     vLineAt(board, r1, c1) or vLineAt(board, r2, c2):\n",
    "    # Swap them back\n",
    "    swap(board, r1, c1, r2, c2)\n",
    "    return True\n",
    "\n",
    "  # Swap them back\n",
    "  swap(board, r1, c1, r2, c2)\n",
    "\n",
    "  return False\n",
    "\n",
    "def hint(board):\n",
    "  # Check for a hint that involves swapping pieces that are side by side\n",
    "  for r in range(len(board)):\n",
    "    for c in range(len(board[0])-1):\n",
    "      if canSwap(board, r, c, r, c+1):\n",
    "        return r, c, r, c+1\n",
    "\n",
    "  # Check for a hint that involves swapping pieces that are one below the other\n",
    "  for r in range(len(board)-1):\n",
    "    for c in range(len(board[0])):\n",
    "      if canSwap(board, r, c, r + 1, c):\n",
    "        return r, c, r+1, c\n",
    "\n",
    "  # Nothing could be swapped\n",
    "  return -1, -1, -1, -1\n",
    "\n",
    "def clearAll(board, sym):\n",
    "  for r in range(len(board)):\n",
    "    for c in range(len(board[0])):\n",
    "      if board[r][c] == sym:\n",
    "        board[r][c] = EMPTY\n",
    "\n",
    "##############################################################################\n",
    "#\n",
    "# End of code \n",
    "#\n",
    "##############################################################################\n",
    "\n",
    "\"\"\"\n",
    "Determine whether or not a function exists in the namespace at the time\n",
    "this function is called\n",
    "Parameters:\n",
    "  name: The name of the function to check the existence of\n",
    "Returns: True if the function exists, False otherwise\n",
    "\"\"\"\n",
    "def functionExists(name):\n",
    "  members = inspect.getmembers(sys.modules[__name__])\n",
    "  for (n, m) in members:\n",
    "    if n == name and inspect.isfunction(m):\n",
    "      return True\n",
    "  return False\n",
    "\n",
    "#\n",
    "#  Load the sprites stored in fname\n",
    "#\n",
    "def loadSpriteSheet(fname):\n",
    "  sheet = loadImage(fname)\n",
    "  root = tk.Tk()\n",
    "  bg = tk.PhotoImage()\n",
    "  bg.tk.call(bg, 'copy', sheet, '-from', 0, 0, 800, 600, '-to', 0, 0)\n",
    "\n",
    "  images = []\n",
    "  sel_images = []\n",
    "  y = 600\n",
    "  for i in range(7):\n",
    "    images.append(tk.PhotoImage())\n",
    "    images[-1].tk.call(images[-1], 'copy', sheet, '-from', 0, y, 50, y+50, '-to', 0, 0)\n",
    "    y += 50\n",
    "\n",
    "    sel_images.append(tk.PhotoImage())\n",
    "    sel_images[-1].tk.call(sel_images[-1], 'copy', sheet, '-from', 0, y, 50, y+50, '-to', 0, 0)\n",
    "    y += 50\n",
    "\n",
    "  images.append(tk.PhotoImage())\n",
    "  images[-1].tk.call(images[-1], 'copy', sheet, '-from', 0, y, 50, y+50, '-to', 0, 0)\n",
    "  sel_images.append(tk.PhotoImage())\n",
    "  sel_images[-1].tk.call(sel_images[-1], 'copy', sheet, '-from', 0, y, 50, y+50, '-to', 0, 0)\n",
    "  y += 50\n",
    "\n",
    "  win_image = tk.PhotoImage()\n",
    "  win_image.tk.call(win_image, 'copy', sheet, '-from', 0, y, 400, y+200, '-to', 0, 0)\n",
    "\n",
    "  lose_image = tk.PhotoImage()\n",
    "  lose_image.tk.call(lose_image, 'copy', sheet, '-from', 0, y+200, 400, y+400, '-to', 0, 0)\n",
    "\n",
    "  cc_m = tk.PhotoImage()\n",
    "  cc_m.tk.call(cc_m, 'copy', sheet, '-from', 0, 1750, 379, 1750+44, '-to', 0, 0)\n",
    "\n",
    "  cc_b = tk.PhotoImage()\n",
    "  cc_b.tk.call(cc_b, 'copy', sheet, '-from', 0, 1794, 379, 1794+44, '-to', 0, 0)\n",
    "\n",
    "  return bg, images, sel_images, win_image, lose_image, cc_m, cc_b\n",
    "\n",
    "def drawItem(item, x, y, images):\n",
    "  if item != EMPTY:\n",
    "    drawImage(images[item], x, y)\n",
    "\n",
    "def drawBoard(board, x, y, sr, sc, images, sel_images):\n",
    "  background(\"black\")\n",
    "  for r in range(len(board)):\n",
    "    for c in range(len(board[r])):\n",
    "      # Draw an item that is selected in a different color\n",
    "      if r == sr and c == sc and board[r][c] != EMPTY:\n",
    "        drawImage(sel_images[board[sr][sc]], x + sc * 50, y + sr * 50)\n",
    "      else:\n",
    "        drawItem(board[r][c], x + c * 50, y + r * 50, images)\n",
    "\n",
    "def allSame(a, b, c, d, e=None): \n",
    "  if e == None:\n",
    "    if a % 10 == b % 10 and b % 10 == c % 10 and c % 10 == d % 10:\n",
    "      return True\n",
    "    return False\n",
    "\n",
    "def transpose(l1, l2):\n",
    "    # iterate over list l1 to the length of an item\n",
    "    for i in range(len(l1[0])):\n",
    "        # print(i)\n",
    "        row =[]\n",
    "        for item in l1:\n",
    "            # appending to new list with values and index positions\n",
    "            # i contains index position and item contains values\n",
    "            row.append(item[i])\n",
    "        l2.append(row)\n",
    "    return l2\n",
    "\n",
    "def collapse(board, syncAnim, asyncAnim, sf, num_syms):\n",
    "#  print(\"Inside collapse...\")\n",
    "\n",
    "  l1 = list(range(50))\n",
    "  l2 = list(range(50))\n",
    "  l3 = list(range(50))\n",
    "  l4 = list(range(50))\n",
    "  l5 = list(range(50))\n",
    "  shuffle(l1)\n",
    "  shuffle(l2)\n",
    "  shuffle(l3)\n",
    "  shuffle(l4)\n",
    "  shuffle(l5)\n",
    "\n",
    "  old_board = deepcopy(board)\n",
    "  changed = False\n",
    "\n",
    "  # 4 horizontal\n",
    "  for r in range(len(board) - 1, -1, -1):\n",
    "    for c in range(len(board[0])-3):\n",
    "      if board[r][c] != EMPTY and board[r][c] != BURST and allSame(board[r][c], board[r][c+1], board[r][c+2], board[r][c+3]):\n",
    "        board[r][c] = EMPTY\n",
    "        board[r][c+1] = EMPTY\n",
    "        board[r][c+2] = EMPTY\n",
    "        board[r][c+3] = EMPTY\n",
    "        changed = True\n",
    "        asyncAnim.append((\"score\", r, c+1, old_board[r][c], 60 * sf, time(), time()+1))\n",
    "        sf += 1\n",
    "\n",
    "#   # 4 vertical\n",
    "#   for r in range(len(board) - 3 - 1, -1, -1):\n",
    "#     for c in range(len(board[0])):\n",
    "#       if board[r][c] != EMPTY and board[r][c] != BURST and allSame(board[r][c], board[r+1][c], board[r+2][c], board[r+3][c]):\n",
    "#         board[r][c] = EMPTY\n",
    "#         board[r+1][c] = EMPTY\n",
    "#         board[r+2][c] = EMPTY\n",
    "#         board[r+3][c] = EMPTY\n",
    "#         changed = True\n",
    "#         asyncAnim.append((\"score\", r+1, c, old_board[r][c], 60 * sf, time(), time()+1))\n",
    "#         sf += 1\n",
    "  \n",
    "  ##for row case\n",
    "  if True:   \n",
    "   l=0\n",
    "   count=0\n",
    "   arr = board\n",
    "   x = id_final\n",
    "   n = len(arr)\n",
    " \n",
    "   for i in range(n):\n",
    "    for j in x:\n",
    "  #for 8 case    \n",
    "      if (len(j)==8):\n",
    "        for l in range (len(arr)-7):\n",
    "            \n",
    "              count+=1  \n",
    "              if arr[i][l:l+8]==j[0:8]:\n",
    "                for m in range(l,l+8):\n",
    "                      arr[i][m]=-1\n",
    "                changed = True\n",
    "                asyncAnim.append((\"score\", i, l, old_board[i][l:l+8], 60 * sf, time(), time()+1))\n",
    "                sf += 1\n",
    "  #for 7 case                    \n",
    "      if (len(j)==7):\n",
    "        for l in range (len(arr)-6):\n",
    "            \n",
    "              count+=1  \n",
    "              if arr[i][l:l+7]==j[0:7]:\n",
    "                  for m in range(l,l+7):\n",
    "                        arr[i][m]=-1\n",
    "                  changed = True\n",
    "                  asyncAnim.append((\"score\", i, l, old_board[i][l:l+7], 50 * sf, time(), time()+1))\n",
    "                  sf += 1\n",
    "  #for 6 case                   \n",
    "      if (len(j)==6):\n",
    "        for l in range (len(arr)-5):\n",
    "            \n",
    "              count+=1  \n",
    "              if arr[i][l:l+6]==j[0:6]:\n",
    "                  for m in range(l,l+6):\n",
    "                        arr[i][m]=-1\n",
    "                  changed = True\n",
    "                  asyncAnim.append((\"score\", i, l, old_board[i][l:l+6], 40 * sf, time(), time()+1))\n",
    "                  sf += 1\n",
    "  #for 5 case                    \n",
    "      if (len(j)==5):\n",
    "        for l in range (len(arr)-4):\n",
    "            \n",
    "              count+=1  \n",
    "              if arr[i][l:l+5]==j[0:5]:\n",
    "                  for m in range(l,l+5):\n",
    "                        arr[i][m]=-1 \n",
    "                  changed = True\n",
    "                  asyncAnim.append((\"score\", i, l, old_board[i][l:l+5], 30 * sf, time(), time()+1))\n",
    "                  sf += 1    \n",
    "  ##for  4 case            \n",
    "      if(len(j)==4) :\n",
    "        for l in range (len(arr)-3):\n",
    "            \n",
    "            count+=1  \n",
    "            if arr[i][l:l+4]==j[0:4]:\n",
    "                  for m in range(l,l+4):\n",
    "                        arr[i][m]=-1 \n",
    "                  changed = True\n",
    "                  asyncAnim.append((\"score\", i, l, old_board[i][l:l+4], 20 * sf, time(), time()+1))\n",
    "                  sf += 1 \n",
    "                            \n",
    "  ##for 3 case \n",
    "    \n",
    "      if (len(j)==3):\n",
    "        for l in range (len(arr)-2):\n",
    "            \n",
    "              count+=1  \n",
    "              if arr[i][l:l+3]==j[0:3]:\n",
    "                for m in range(l,l+3):\n",
    "                        arr[i][m]=-1\n",
    "                changed = True\n",
    "                asyncAnim.append((\"score\", i, l, old_board[i][l:l+8], 10 * sf, time(), time()+1))\n",
    "                sf += 1\n",
    "   board = arr\n",
    "\n",
    "  #for column case\n",
    "  if False:\n",
    "   l=0\n",
    "   count=0\n",
    "   arr=[]\n",
    "   sf = 0\n",
    "   arry= transpose(board,arr)\n",
    "   x = id_final\n",
    "   n = len(arr)\n",
    " \n",
    "   for i in range(n):\n",
    "    for j in x:\n",
    "    #for 8 case    \n",
    "      if (len(j)==8):\n",
    "        for l in range (len(arr)-7):\n",
    "            \n",
    "              count+=1  \n",
    "              if (arr[i][l:l+8]==j[0:8]):\n",
    "                  for m in range(l,l+8):\n",
    "                        arr[m][i]=-1\n",
    "                  changed = True\n",
    "                #   board = arr.tolist()\n",
    "                  asyncAnim.append((\"score\", i, l, old_board[i][l:l+8], 0 * sf, time(), time()+1))\n",
    "                  sf += 1\n",
    "   #for 7 case\n",
    "      if (len(j)==7):\n",
    "        for l in range (len(arr)-6):\n",
    "            \n",
    "              count+=1  \n",
    "              if (arr[i][l:l+7]==j[0:7]):\n",
    "                  for m in range(l,l+7):\n",
    "                        arr[m][i]=-1\n",
    "                  changed = True\n",
    "                #   board = arr.tolist()\n",
    "                  asyncAnim.append((\"score\", i, l, old_board[i][l:l+7], 0 * sf, time(), time()+1))\n",
    "                  sf += 1\n",
    "   #for 6 case\n",
    "      if (len(j)==6):\n",
    "        for l in range (len(arr)-5):\n",
    "            \n",
    "              count+=1  \n",
    "              if (arr[i][l:l+6]==j[0:6]):\n",
    "                  for m in range(l,l+6):\n",
    "                        arr[m][i]=-1\n",
    "                  changed = True\n",
    "                #   board = arr.tolist()\n",
    "                  asyncAnim.append((\"score\", i, l, old_board[i][l:l+6], 0 * sf, time(), time()+1))\n",
    "                  sf += 1\n",
    "   #for 5 case                    \n",
    "      if (len(j)==5):\n",
    "        for l in range (len(arr)-4):\n",
    "            \n",
    "              count+=1  \n",
    "              if (arr[i][l:l+5]==j[0:5]):\n",
    "                  for m in range(l,l+5):\n",
    "                        arr[m][i]=-1\n",
    "                  changed = True\n",
    "                #   board = arr.tolist()\n",
    "                  asyncAnim.append((\"score\", i, l, old_board[i][l:l+5], 0 * sf, time(), time()+1))\n",
    "                  sf += 1           \n",
    "    ##for  4 case            \n",
    "      if(len(j)==4) :\n",
    "        for l in range (len(arr)-3):\n",
    "            \n",
    "            count+=1  \n",
    "            if (arr[i][l:l+4]==j[0:4]):\n",
    "                  for m in range(l,l+4):\n",
    "                        arr[m][i]=-1  \n",
    "                  changed = True\n",
    "                #   board = arr.tolist()\n",
    "                  asyncAnim.append((\"score\", i, l, old_board[i][l:l+4], 0 * sf, time(), time()+1))\n",
    "                  sf += 1   \n",
    "    ##for 3 case \n",
    "      if (len(j)==3):\n",
    "        for l in range (len(arr)-2):\n",
    "            \n",
    "              count+=1  \n",
    "              if (arr[i][l:l+3]==j[0:3]):\n",
    "                for m in range(l,l+3):\n",
    "                        arr[m][i]=-1\n",
    "                changed = True\n",
    "                # board = arr.tolist()\n",
    "                asyncAnim.append((\"score\", i, l, old_board[i][l:l+3], 60 * sf, time(), time()+1))\n",
    "                sf += 1\n",
    "\n",
    "    board = []\n",
    "    board = transpose(arr,board)\n",
    "\n",
    "  # Destroy everything that has been changed to empty\n",
    "  num_destroyed = 0\n",
    "  if changed:\n",
    "    for c in range(len(board[0])):\n",
    "      for r in range(len(board)):\n",
    "        if board[r][c] == EMPTY:\n",
    "          syncAnim.append((\"destroy\", r, c, old_board[r][c], l1, time(), time()+1))\n",
    "          num_destroyed += 1\n",
    "\n",
    "  #print(\"num_destroyed is\", num_destroyed)\n",
    "  if num_destroyed > 0:\n",
    "    time_delay = 1\n",
    "  else:\n",
    "    time_delay = 0\n",
    "\n",
    "  genFalls(board, time_delay, syncAnim, num_syms)\n",
    "\n",
    "  if changed == False:\n",
    "    return 1\n",
    "  else:\n",
    "    return sf\n",
    "\n",
    "def genFalls(board, time_delay, syncAnim, num_syms):\n",
    "  # Add falling to the animation queue\n",
    "  for c in range(len(board[0])):\n",
    "    b = blanksBelow(board, -1, c)\n",
    "    if b > 0:\n",
    "      for i in range(b):\n",
    "        # New piece falling in from the top of the board\n",
    "        syncAnim.insert(0, (\"fall\", -1 - i, c, random.choice([0,1,1,1,2,2,2,3,3,3,3,4,4,4]), b, time()+time_delay, time()+time_delay+b))\n",
    "\n",
    "    count = 0\n",
    "    for r in range(len(board)):\n",
    "      if board[r][c] != EMPTY:\n",
    "        b = blanksBelow(board, r, c)\n",
    "        if b > 0:\n",
    "          # Pieces within the board fall\n",
    "          syncAnim.insert(0, (\"fall\", r, c, board[r][c], b, time()+time_delay, time()+time_delay+b))\n",
    "          board[r][c] = EMPTY\n",
    "\n",
    "\n",
    "def blanksBelow(board, r, c):\n",
    "  count = 0\n",
    "  for i in range(r+1, len(board)):\n",
    "    if board[i][c] == EMPTY:\n",
    "      count = count + 1\n",
    "  return count\n",
    "\n",
    "def nonBlanksAbove(board, row, col, num, num_syms):\n",
    "  r = row - 1\n",
    "  count = 0\n",
    "  while r >= 0 and count != num:\n",
    "    if board[r][col] != EMPTY:\n",
    "      count = count + 1\n",
    "    r = r - 1\n",
    "\n",
    "  if r >= 0:\n",
    "    return board[r][col], r\n",
    "  else:\n",
    "    return random.choice([0,0,0,1,1,1,2,2,2,3,3,3,3,4,4,4]), -1\n",
    "\n",
    "def blanksImmediatelyAbove(board, row, col):\n",
    "  count = 0\n",
    "  r = row - 1\n",
    "  while r >= 0 and board[r][col] == EMPTY:\n",
    "    r = r - 1\n",
    "    count = count + 1\n",
    "\n",
    "  return count\n",
    "\n",
    "\n",
    "def nextAbove(board, r, c):\n",
    "  if board[r][c] != EMPTY:\n",
    "    raise \"Error: nextAbove called on a non-empty location\"\n",
    "\n",
    "  while r >= 0:\n",
    "    if board[r][c] != EMPTY:\n",
    "      return r \n",
    "    r = r - 1\n",
    "\n",
    "  return r\n",
    "\n",
    "def hasAnimType(anims, t):\n",
    "  for a in anims:\n",
    "    if a[0] == t:\n",
    "      return True\n",
    "  return False\n",
    "\n",
    "def gray50(x, y, w, h):\n",
    "  for i in range(x, x + w):\n",
    "    if i % 2 == 0:\n",
    "      line(i, y, i, y + h)\n",
    "\n",
    "  for i in range(y, y + h):\n",
    "    if i % 2 == 0:\n",
    "      line(x, i, x + w, i)\n",
    "  \"\"\"\n",
    "  for i in range(x, x + w):\n",
    "    for j in range(y, y + h):\n",
    "      if (i + j) % 2 == 0:\n",
    "        line(i, j, i, j)\n",
    "        \"\"\"\n",
    "\n",
    "#play(target_score, max_turns, rows, cols, syms)\n",
    "def play(target_score, turns_left, num_rows, num_cols, num_syms, bg, cc_m, images, sel_images, win_image, lose_image):\n",
    "  hoff = HOFF + (8 - num_cols) * 25\n",
    "  voff = VOFF + (8 - num_rows) * 25\n",
    "\n",
    "  frame_count = 0\n",
    "  last_time = time()\n",
    "\n",
    "  selected_r = -1\n",
    "  selected_c = -1\n",
    "\n",
    "  setFont(\"Arial\", s=24)\n",
    "  score_width = max(textWidth(\"Score:\"), textWidth(\"000000\"))\n",
    "  score = 0\n",
    "#  turns_left = 1\n",
    "\n",
    "  syncAnim = []\n",
    "#  syncAnim.append((\"pause\", time(), time()+3))\n",
    "  asyncAnim = []\n",
    "\n",
    "  #board = createBoard(8, 8, 5)\n",
    "  board = createBoard(num_rows, num_cols, num_syms)\n",
    "  clear()\n",
    "  drawBoard(board, hoff, voff, -1, -1, images, sel_images)\n",
    "\n",
    "  drawImage(bg, 0, 0)\n",
    "  drawImage(cc_m, 23, 23)\n",
    "  drawStatus(score, score_width, target_score, turns_left)\n",
    "  update()\n",
    "  sleep(0.5)\n",
    "  clearMouseEvents()\n",
    "\n",
    "  score_factor = collapse(board, syncAnim, asyncAnim, 1, num_syms)\n",
    "\n",
    "  setAutoUpdate(False)\n",
    "\n",
    "  game_state = RUNNING\n",
    "\n",
    "  while not closed():\n",
    "    clear()\n",
    "    drawBoard(board, hoff, voff, selected_r, selected_c, images, sel_images)\n",
    "\n",
    "    if len(syncAnim) == 0:\n",
    "      score_factor = collapse(board, syncAnim, asyncAnim, score_factor, num_syms)\n",
    "    if game_state == LOSE and len(syncAnim) == 0:\n",
    "      syncAnim.append((\"Lose\", time() + 0.1))\n",
    "    if game_state == WIN and len(syncAnim) == 0:\n",
    "      syncAnim.append((\"Win\", time() + 0.1))\n",
    "\n",
    "    if turns_left == 0 and score < target_score:\n",
    "      game_state = LOSE\n",
    "    if score >= target_score:\n",
    "      game_state = WIN\n",
    "\n",
    "    if len(syncAnim) > 0:\n",
    "      index = 0\n",
    "      setColor(\"black\")\n",
    "      while index < len(syncAnim):\n",
    "        if index < len(syncAnim) and syncAnim[index][0] == \"Win\":\n",
    "          ct = time()\n",
    "          et = syncAnim[index][1]\n",
    "          if ct >= et:\n",
    "            gray50(hoff, voff, 400, 400)\n",
    "            drawImage(win_image, getWidth() // 2 - getWidth(win_image) // 2,\n",
    "                      getHeight() // 2 - getHeight(win_image) // 2)\n",
    "          index += 1\n",
    "        if index < len(syncAnim) and syncAnim[index][0] == \"Lose\":\n",
    "          ct = time()\n",
    "          et = syncAnim[index][1]\n",
    "          if ct >= et:\n",
    "            gray50(hoff, voff, 400, 400)\n",
    "            drawImage(lose_image, getWidth() // 2 - getWidth(lose_image) // 2,\n",
    "                      getHeight() // 2 - getHeight(lose_image) // 2)\n",
    "          index += 1\n",
    "        if index < len(syncAnim) and syncAnim[index][0] == \"fall\":\n",
    "          r1 = syncAnim[index][1]\n",
    "          c1 = syncAnim[index][2]\n",
    "          v1 = syncAnim[index][3]\n",
    "          b = syncAnim[index][4]\n",
    "          st = syncAnim[index][5]\n",
    "          et = syncAnim[index][6]\n",
    "          ct = time()\n",
    "\n",
    "          percent = (ct - st) / (et - st)\n",
    "          if percent > 1:\n",
    "            syncAnim.pop(index)\n",
    "            percent = 1\n",
    "            board[r1+b][c1] = v1\n",
    "          else:\n",
    "            index = index + 1\n",
    "\n",
    "          if percent <= 0:\n",
    "            drawItem(v1, hoff + c1 * 50, voff + r1 * 50, images)\n",
    "            pass\n",
    "          if percent > 0:\n",
    "            drawItem(v1, hoff + c1 * 50, voff + r1 * 50 + percent * b * 50, images)\n",
    "          \n",
    "          \n",
    "        if index < len(syncAnim) and syncAnim[index][0] == \"pause\":\n",
    "          st = syncAnim[index][0]\n",
    "          et = syncAnim[index][1]\n",
    "          ct = time()\n",
    "          if ct < et:\n",
    "            index = index + 1\n",
    "          else:\n",
    "            syncAnim.pop(index)\n",
    "\n",
    "        if index < len(syncAnim) and syncAnim[index][0] == \"destroy\":\n",
    "          r1 = syncAnim[index][1]\n",
    "          c1 = syncAnim[index][2]\n",
    "          v1 = syncAnim[index][3]\n",
    "          cols = syncAnim[index][4]\n",
    "          st = syncAnim[index][5]\n",
    "          et = syncAnim[index][6]\n",
    "          ct = time()\n",
    "\n",
    "\n",
    "          percent = (ct - st) / (et - st)\n",
    "\n",
    "          if percent >= 0:\n",
    "            drawItem(v1, hoff + c1 * 50, voff + r1 * 50, images)\n",
    "          if percent > 1:\n",
    "            syncAnim.pop(index)\n",
    "            percent = 1\n",
    "\n",
    "            board[r1][c1] = EMPTY\n",
    "\n",
    "\n",
    "          else:\n",
    "            index = index + 1\n",
    "\n",
    "          setColor(\"black\")\n",
    "          for i in range(0, round(50 * percent)):\n",
    "            line(hoff + c1 * 50 + cols[i], voff + r1 * 50,\n",
    "                 hoff + c1 * 50 + cols[i], voff + r1 * 50 + 49)\n",
    "\n",
    "        if index < len(syncAnim) and syncAnim[index][0] == \"swap\":\n",
    "          r1 = syncAnim[index][1]\n",
    "          c1 = syncAnim[index][2]\n",
    "          v1 = syncAnim[index][3]\n",
    "          r2 = syncAnim[index][4]\n",
    "          c2 = syncAnim[index][5]\n",
    "          v2 = syncAnim[index][6]\n",
    "          st = syncAnim[index][7]\n",
    "          et = syncAnim[index][8]\n",
    "          ct = time()\n",
    "\n",
    "          percent = (ct - st) / (et - st)\n",
    "          if percent > 1:\n",
    "            syncAnim.pop(index)\n",
    "            percent = 1\n",
    "          else:\n",
    "            index = index + 1\n",
    "\n",
    "          setColor(\"black\")\n",
    "          rect(hoff + c1 * 50, voff + r1 * 50, 50, 50)\n",
    "          rect(hoff + c2 * 50, voff + r2 * 50, 50, 50)\n",
    "\n",
    "          if abs(c1 - c2) == 1:\n",
    "            drawItem(v2, \n",
    "                     hoff + c2 * 50 + (c1 - c2) * (percent) * 50, \n",
    "                     voff + r2 * 50 + (r1 - r2) * (percent) * 50 + \n",
    "                       sin(percent * 3.14) * 25, images)\n",
    "            drawItem(v1, \n",
    "                     hoff + c2 * 50 + (c1 - c2) * (1 - percent) * 50, \n",
    "                     voff + r2 * 50 + (r1 - r2) * (1 - percent) * 50 - \n",
    "                       sin(percent * 3.14) * 25, images)\n",
    "          else:\n",
    "            drawItem(v2, \n",
    "                     hoff + c2 * 50 + (c1 - c2) * (percent) * 50 + \n",
    "                       sin(percent * 3.14) * 25, \n",
    "                     voff + r2 * 50 + (r1 - r2) * (percent) * 50, images)\n",
    "            drawItem(v1, \n",
    "                     hoff + c2 * 50 + (c1 - c2) * (1 - percent) * 50 - \n",
    "                       sin(percent * 3.14) * 25, \n",
    "                     voff + r2 * 50 + (r1 - r2) * (1 - percent) * 50, images)\n",
    "\n",
    "        if index < len(syncAnim) and syncAnim[index][0] == \"crossfade\":\n",
    "          r = syncAnim[index][1]\n",
    "          c = syncAnim[index][2]\n",
    "          v1 = syncAnim[index][3]\n",
    "          st = syncAnim[index][4]\n",
    "          et = st + 1\n",
    "          ct = time()\n",
    "\n",
    "          percent = (ct - st) / (et - st)\n",
    "          if percent > 1:\n",
    "            syncAnim.pop(index)\n",
    "            percent = 1\n",
    "          else:\n",
    "            index = index + 1\n",
    "\n",
    "          w = getWidth(images[v1])\n",
    "          h = getHeight(images[v1])\n",
    "          cf = createImage(w, h)\n",
    "\n",
    "          image1 = images[v1]\n",
    "          image2 = images[BURST]\n",
    "\n",
    "          for x in range(w):\n",
    "            for y in range(h):\n",
    "              r1, g1, b1 = getPixel(image1, x, y)\n",
    "              r2, g2, b2 = getPixel(image2, x, y)\n",
    "              p2 = min(percent, 1.0)\n",
    "              p1 = max(1 - percent, 0)\n",
    "              putPixel(cf, x, y, \n",
    "                       round(r1 * p1 + r2 * p2),\n",
    "                       round(g1 * p1 + g2 * p2),\n",
    "                       round(b1 * p1 + b2 * p2))\n",
    "\n",
    "          drawImage(cf, hoff + c * w, voff + r * h)\n",
    "\n",
    "\n",
    "        if index < len(syncAnim) and syncAnim[index][0] == \"swap_and_back\":\n",
    "          r1 = syncAnim[index][1]\n",
    "          c1 = syncAnim[index][2]\n",
    "          v1 = syncAnim[index][3]\n",
    "          r2 = syncAnim[index][4]\n",
    "          c2 = syncAnim[index][5]\n",
    "          v2 = syncAnim[index][6]\n",
    "          st = syncAnim[index][7]\n",
    "          et = syncAnim[index][8]\n",
    "          ct = time()\n",
    "\n",
    "          percent = (ct - st) / (et - st)\n",
    "          if percent > 1:\n",
    "            syncAnim.pop(index)\n",
    "            percent = 1\n",
    "          else:\n",
    "            index = index + 1\n",
    "\n",
    "          rect(hoff + c1 * 50, voff + r1 * 50, 50, 50)\n",
    "          rect(hoff + c2 * 50, voff + r2 * 50, 50, 50)\n",
    "\n",
    "          if percent < 0.5:\n",
    "            np = percent * 2\n",
    "          else:\n",
    "            np = (percent * -1 + 1) * 2\n",
    "\n",
    "          if abs(c1 - c2) == 1:\n",
    "            drawItem(v2, \n",
    "                     hoff + c2 * 50 + (c1 - c2) * (np) * 50, \n",
    "                     voff + r2 * 50 + (r1 - r2) * (np) * 50 + \n",
    "                       sin(np * 3.14) * 25, images)\n",
    "            drawItem(v1, \n",
    "                     hoff + c2 * 50 + (c1 - c2) * (1 - np) * 50, \n",
    "                     voff + r2 * 50 + (r1 - r2) * (1 - np) * 50 - \n",
    "                       sin(np * 3.14) * 25, images)\n",
    "          else:\n",
    "            drawItem(v2, \n",
    "                     hoff + c2 * 50 + (c1 - c2) * (np) * 50 + \n",
    "                       sin(np * 3.14) * 25, \n",
    "                     voff + r2 * 50 + (r1 - r2) * (np) * 50, images)\n",
    "            drawItem(v1, \n",
    "                     hoff + c2 * 50 + (c1 - c2) * (1 - np) * 50 - \n",
    "                       sin(np * 3.14) * 25, \n",
    "                     voff + r2 * 50 + (r1 - r2) * (1 - np) * 50, images)\n",
    "\n",
    "      if len(syncAnim) == 0:\n",
    "        clearMouseEvents()\n",
    "    elif peekMouseEvent() != None:\n",
    "      mv = getMouseEvent()\n",
    "      # Deselect\n",
    "      if mv[0] == \"<Button-2>\" or mv[0] == \"<Button-3>\":\n",
    "        selected_r = -1\n",
    "        selected_c = -1\n",
    "      if mv[0] == \"<Button-1>\":\n",
    "        if selected_r == -1 and selected_c == -1 and mv[1][1] >= voff and mv[1][0] > hoff and mv[1][1] < voff + len(board) * 50 and mv[1][0] < hoff + len(board[0]) * 50:\n",
    "          selected_r = (mv[1][1] - voff) // 50\n",
    "          selected_c = (mv[1][0] - hoff) // 50\n",
    "        elif mv[1][1] >= voff and mv[1][0] > hoff and mv[1][1] < voff + len(board) * 50 and mv[1][0] < hoff + len(board[0]) * 50:\n",
    "          second_r = (mv[1][1] - voff) // 50\n",
    "          second_c = (mv[1][0] - hoff) // 50\n",
    "          \n",
    "          if selected_r == second_r and abs(selected_c - second_c) == 1 or \\\n",
    "             selected_c == second_c and abs(selected_r - second_r) == 1:\n",
    "            if (board[selected_r][selected_c] == BURST and \\\n",
    "                board[second_r][second_c] != BURST) or \\\n",
    "               (board[second_r][second_c] == BURST and \\\n",
    "                board[selected_r][selected_c] != BURST):\n",
    "              if board[second_r][second_c] == BURST and \\\n",
    "                 board[selected_r][selected_c] != BURST:\n",
    "                   selected_r, second_r = second_r, selected_r\n",
    "                   selected_c, second_c = second_c, selected_c\n",
    "              turns_left -= 1\n",
    "              target_color = board[second_r][second_c]\n",
    "              syncAnim.append((\"swap\", selected_r, selected_c, \n",
    "                               board[selected_r][selected_c], \n",
    "                               second_r, second_c, board[second_r][second_c],\n",
    "                               current_time, current_time+0.5))\n",
    "              swap(board, selected_r, selected_c, second_r, second_c)\n",
    "\n",
    "              new_board = deepcopy(board)\n",
    "              clearAll(new_board, target_color)\n",
    "\n",
    "              st = time()\n",
    "              for r in range(len(board)):\n",
    "                for c in range(len(board[0])):\n",
    "                  if new_board[r][c] == EMPTY:\n",
    "                    l1 = list(range(50))\n",
    "                    shuffle(l1)\n",
    "                    syncAnim.append((\"destroy\", r, c, target_color, l1, st+0.5, st+1.5))\n",
    "                    asyncAnim.append((\"score\", r, c, target_color, 30, time()+0.5))\n",
    "              syncAnim.append((\"destroy\", second_r, second_c, BURST, l1, st+0.5, st+1.5))\n",
    "              asyncAnim.append((\"score\", second_r, second_c, target_color, 30, time()+0.5))\n",
    "\n",
    "\n",
    "              board[second_r][second_c] = EMPTY\n",
    "              board[selected_r][selected_c] = EMPTY\n",
    "\n",
    "            elif canSwap(board, selected_r, selected_c, second_r, second_c):\n",
    "              turns_left -= 1\n",
    "              syncAnim.append((\"swap\", selected_r, selected_c, \n",
    "                               board[selected_r][selected_c], \n",
    "                               second_r, second_c, board[second_r][second_c],\n",
    "                               current_time, current_time+0.5))\n",
    "              swap(board, selected_r, selected_c, second_r, second_c)\n",
    "            else:\n",
    "              syncAnim.append((\"swap_and_back\", selected_r, selected_c, \n",
    "                               board[selected_r][selected_c], \n",
    "                               second_r, second_c, board[second_r][second_c],\n",
    "                               current_time, current_time+0.75))\n",
    "            selected_r = -1\n",
    "            selected_c = -1\n",
    "          else:\n",
    "            selected_r = second_r\n",
    "            selected_c = second_c\n",
    "            second_r = -1\n",
    "            second_c = -1\n",
    "    if (8 - num_rows) * 25 > 0:\n",
    "      setColor(\"black\")\n",
    "      rect(HOFF, VOFF, 400, (8 - num_rows) * 25)\n",
    "    drawImage(bg, 0, 0)\n",
    "    drawImage(cc_m, 23, 23)\n",
    "\n",
    "    keys = getKeys()\n",
    "    if (('h' in keys) or ('H' in keys)) and len(syncAnim) == 0:\n",
    "      r1, c1, r2, c2 = hint(board)\n",
    "      if (r1 == -1) and (c1 == -1) and (r2 == -1) and (c2 == -1):\n",
    "        asyncAnim.append((\"no moves\", time()))\n",
    "      else:\n",
    "        asyncAnim.append((\"hint\", r1, c1, r2, c2, time()))\n",
    "\n",
    "    if (('r' in keys) or ('R' in keys)) and \\\n",
    "       (hint(board) == (-1, -1, -1, -1)) and \\\n",
    "       len(syncAnim) == 0:\n",
    "      for r in range(len(board)):\n",
    "        for c in range(len(board[r])):\n",
    "          board[r][c] = EMPTY\n",
    "\n",
    "\n",
    "        \n",
    "    drawStatus(score, score_width, target_score, turns_left)\n",
    "    index = 0\n",
    "    while index < len(asyncAnim):\n",
    "      if index < len(asyncAnim) and asyncAnim[index][0] == \"no moves\":\n",
    "        st = asyncAnim[index][1]\n",
    "        et = st + 1.5\n",
    "        ct = time()\n",
    "\n",
    "        percent = (ct - st) / (et - st)\n",
    "        if percent > 1:\n",
    "          asyncAnim.pop(index)\n",
    "          percent = 1\n",
    "        else:\n",
    "          index = index + 1\n",
    "\n",
    "        # Technically not cross fading, but by only going back to (50, 50, 50)\n",
    "        # we get something that is close enough that there isn't a visual 'pop'\n",
    "        intensity = 50 + 205 * sin(percent * pi)\n",
    "\n",
    "        setColor(intensity, intensity, intensity)\n",
    "        text(getWidth() // 2, 550, \"No Hint Available\")\n",
    "\n",
    "      if index < len(asyncAnim) and asyncAnim[index][0] == \"hint\":\n",
    "        r1 = asyncAnim[index][1]\n",
    "        c1 = asyncAnim[index][2]\n",
    "        r2 = asyncAnim[index][3]\n",
    "        c2 = asyncAnim[index][4]\n",
    "        st = asyncAnim[index][5]\n",
    "        et = st + 1\n",
    "        ct = time()\n",
    "\n",
    "        percent = (ct - st) / (et - st)\n",
    "        if percent > 1:\n",
    "          asyncAnim.pop(index)\n",
    "          percent = 1\n",
    "        else:\n",
    "          index = index + 1\n",
    "\n",
    "        if percent < 0.5:\n",
    "          intensity = 255 * percent * 2\n",
    "        else:\n",
    "          intensity = 255 * (1 - percent) * 2\n",
    "\n",
    "        setOutline(intensity, intensity, intensity)\n",
    "        setFill(None)\n",
    "\n",
    "        if abs(r1-r2) == 1 and abs(c1-c2) == 0:\n",
    "          rect(hoff + c1 * 50, voff + min(r1, r2) * 50, 50, 100)\n",
    "        elif abs(r1-r2) == 0 and abs(c1-c2) == 1:\n",
    "          rect(hoff + min(c1, c2) * 50, voff + r1 * 50, 100, 50)\n",
    "        else:\n",
    "          rect(hoff + c1 * 50, voff + r1 * 50, 50, 50)\n",
    "          rect(hoff + c2 * 50, voff + r2 * 50, 50, 50)\n",
    "\n",
    "      if index < len(asyncAnim) and asyncAnim[index][0] == \"score\":\n",
    "        r1 = asyncAnim[index][1]\n",
    "        c1 = asyncAnim[index][2]\n",
    "        v1 = asyncAnim[index][3]\n",
    "        a1 = asyncAnim[index][4]\n",
    "        st = asyncAnim[index][5]\n",
    "        et = st + 0.75\n",
    "        ct = time()\n",
    "\n",
    "        percent = (ct - st) / (et - st)\n",
    "        if percent > 1:\n",
    "          asyncAnim.pop(index)\n",
    "          percent = 1\n",
    "          score = score + a1\n",
    "        else:\n",
    "          index = index + 1\n",
    "\n",
    "        if percent >= 0:\n",
    "          x1 = hoff + c1 * 50\n",
    "          y1 = voff + r1 * 50\n",
    "\n",
    "          x = x1 + (SCORE_X - x1) * percent\n",
    "          y = y1 + (SCORE_Y - 100 + 22 - y1) * percent\n",
    "\n",
    "          setColor(\"white\")\n",
    "          text(x, y, a1, \"c\")\n",
    "\n",
    "    update()\n",
    "    current_time = time()\n",
    "    if current_time - last_time < 1/30:\n",
    "      sleep(1/30 - (current_time - last_time))\n",
    "    frame_count = frame_count + 1\n",
    "    last_time = current_time\n",
    "\n",
    "def drawStatus(score, score_width, target_score, turns_left):\n",
    "    setColor(\"black\")\n",
    "    rect(SCORE_X - score_width // 2 - 5, SCORE_Y - 41 - 100, score_width + 10, 72 + 10)\n",
    "    rect(SCORE_X - score_width // 2 - 5, SCORE_Y - 41, score_width + 10, 72 + 10)\n",
    "    rect(SCORE_X - score_width // 2 - 5, SCORE_Y - 41 + 100, score_width + 10, 72 + 10)\n",
    "    setColor(\"white\")\n",
    "    text(SCORE_X, SCORE_Y - 41 - 100 + 22, \"Score:\", \"c\")\n",
    "    text(SCORE_X, SCORE_Y - 41 - 100 + 22 + 36, \"%06d\" % score, \"c\")\n",
    "    text(SCORE_X, SCORE_Y - 41 + 22, \"Target:\", \"c\")\n",
    "    text(SCORE_X, SCORE_Y - 41 + 22 + 36, \"%06d\" % target_score, \"c\")\n",
    "    text(SCORE_X, SCORE_Y - 41 + 100 + 22, \"Turns:\", \"c\")\n",
    "    text(SCORE_X, SCORE_Y - 41 + 100 + 22 + 36, \"%d\" % turns_left, \"c\")\n",
    "\n",
    "\n",
    "def main():\n",
    "  if os.path.isfile(\"sprites.gif\") == False:\n",
    "    print(\"sprites.gif must be located in the same folder / directory as\")\n",
    "    print(\"your .py file.  Ensure that the name of the file is in all\")\n",
    "    print(\"lowercase letters.\")\n",
    "    close()\n",
    "    quit()\n",
    "\n",
    "\n",
    "  bg, images, sel_images, win_image, lose_image, cc_m, cc_b = loadSpriteSheet(\"sprites.gif\")\n",
    "  setAutoUpdate(False)\n",
    "  while not closed():\n",
    "    clear()\n",
    "    background(\"black\")\n",
    "    drawImage(bg, 0, 0)\n",
    "    drawImage(cc_b, getWidth() // 2 - getWidth(cc_b) // 2, 150)\n",
    "  \n",
    "    # Draw the buttons\n",
    "    setFont(\"Arial\", s=24)\n",
    "  \n",
    "    mx, my = mousePos()\n",
    "\n",
    "    y = 250\n",
    "    selected = \"\"\n",
    "    for difficulty in [\"Play\"]:\n",
    "      if my >= y - 20 and my <= y + 20 and mx >= 345 and mx <= 455:\n",
    "        selected = difficulty\n",
    "        setColor(254,199,0)\n",
    "      else:\n",
    "        setColor(\"White\")\n",
    "      text(400, y, difficulty)\n",
    "      y += 70\n",
    "    \n",
    "    #play()\n",
    "    update()\n",
    "\n",
    "    if selected != \"\" and leftButtonPressed():\n",
    "      break\n",
    "  if selected==\"Play\" :\n",
    "   target_score = 5000\n",
    "   max_turns = 35\n",
    "   rows = 8\n",
    "   cols = 8\n",
    "   syms = 5 \n",
    "\n",
    "  play(target_score, max_turns, rows, cols, syms, bg, cc_m, images, sel_images, win_image, lose_image)\n",
    "\n",
    "main()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
